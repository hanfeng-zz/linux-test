// SPDX-License-Identifier: GPL-2.0+
/*
 * userspace interface for au5508 radio module
 *
 * Pi433 is a 433MHz radio module for the Raspberry Pi.
 * It is based on the HopeRf Module RFM69CW. Therefore inside of this
 * driver, you'll find an abstraction of the rf69 chip.
 *
 * If needed, this driver could be extended, to also support other
 * devices, basing on HopeRfs rf69.
 *
 * The driver can also be extended, to support other modules of
 * HopeRf with a similar interace - e. g. RFM69HCW, RFM12, RFM95, ...
 *
 * Copyright (C) 2016 Wolf-Entwicklungen
 *	Marcus Wolf <linux@wolf-entwicklungen.de>
 */

#undef DEBUG

#include <linux/init.h>
#include <linux/module.h>
//#include <linux/idr.h>
#include <linux/ioctl.h>
#include <linux/uaccess.h>
#include <linux/fs.h>
#include <linux/device.h>
#include <linux/cdev.h>
#include <linux/err.h>
#include <linux/kfifo.h>
#include <linux/errno.h>
#include <linux/mutex.h>
#include <linux/of.h>
#include <linux/of_device.h>
#include <linux/spi/spi.h>
#include <linux/idr.h>
#include <linux/gpio/consumer.h>
#include <linux/module.h>
#include <linux/regmap.h>
#include <linux/delay.h>
#include <linux/spi/spidev.h>

#ifdef CONFIG_COMPAT
#include <linux/compat.h>
#endif


#define N_AU5508_MINORS		BIT(MINORBITS) /*32*/	/* ... up to 256 */
#define MAX_MSG_SIZE		900	/* min: FIFO_SIZE! */
#define MSG_FIFO_SIZE		65536   /* 65536 = 2^16  */

#define AU5508_IOCTL_NUM 		 'r'
/* Set Number of Request Blocks */
#define AU5508_SET_CONTEXT		_IOWR(AU5508_IOCTL_NUM, 1, void *)
#define AU5508_GET_CONTEXT		_IOWR(AU5508_IOCTL_NUM, 2, void *)


static dev_t au5508_dev;
static DEFINE_IDR(au5508_idr);

static DEFINE_MUTEX(minor_lock); /* Protect idr accesses */

static struct class *au5508_class; /* mainly for udev to create /dev/au5508 */

typedef struct {
    unsigned int offset;
    unsigned int val;
} au5508_reg;



au5508_reg au5508_register_cfg[] =
{
	// Generated by licaiyun
	// Generated on 20230510 at 16:06:21
	// Version v2.7


	// Step1: HARD Reset
	{ 0x00, 0x00 },
	// GENERIC : begin
	{ 0xff, 0x00 },
	{ 0xbd, 0xc3 },
	{ 0x10, 0x01 },
	{ 0x1a, 0x1f },
	{ 0x1b, 0x1f },
	{ 0x1c, 0x1f },
	{ 0x1d, 0xff },
	{ 0x1e, 0xff },
	{ 0x1f, 0xff },
	{ 0x20, 0xff },
	{ 0x21, 0xff },
	{ 0x22, 0xdf },
	{ 0x23, 0x03 },
	{ 0x24, 0x01 },
	{ 0x25, 0x0f },
	{ 0x28, 0x40 },
	{ 0x29, 0x0e },
	{ 0x2a, 0x60 },
	{ 0x2c, 0xe2 },
	{ 0x2d, 0x3f },
	{ 0x32, 0x1e },
	{ 0x34, 0x6c },
	{ 0x35, 0x99 },
	{ 0x3c, 0x80 },
	{ 0x3f, 0x68 },
	{ 0x40, 0x5a },
	{ 0x50, 0x08 },
	{ 0xe1, 0xff },
	{ 0xe8, 0x10 },
	{ 0xe9, 0x10 },
	{ 0xea, 0x10 },
	{ 0xeb, 0x10 },
	{ 0xef, 0x05 },


	{ 0xff, 0x01 },
	{ 0xbd, 0xc3 },
	{ 0x10, 0x09 },
	{ 0x11, 0x09 },
	{ 0x12, 0x09 },
	{ 0x16, 0x20 },
	{ 0x1c, 0x20 },
	{ 0x22, 0x20 },
	{ 0x28, 0x00 },
	{ 0x29, 0x00 },
	{ 0x2a, 0x00 },
	{ 0x2b, 0x00 },
	{ 0x2c, 0x00 },
	{ 0x2d, 0x00 },
	// Update NVM Bank
	{ 0xff, 0x00 },
	{ 0x0f, 0x10 },
	// force wakeup the slaves
	{ 0xe0, 0xff },
	{ 0xee, 0x05 },
	{ 0x00, 0x00 },
	{ 0xff, 0x00 },
	{ 0xff, 0x00 },
	// Proceed to Loop Lock
	{ 0x0f, 0x40 },
	// GENERIC : end


	// INPUT_SYS : begin
	{ 0xff, 0x02 },
	{ 0xbd, 0xc3 },
	{ 0x10, 0x08 },
	{ 0x11, 0x00 },
	{ 0x12, 0x00 },
	{ 0x13, 0x00 },
	{ 0x14, 0x00 },
	{ 0x15, 0x00 },
	{ 0x16, 0xff },
	{ 0x17, 0xff },
	{ 0x18, 0xff },
	{ 0x19, 0xff },
	{ 0x1a, 0x28 },
	{ 0x1b, 0x23 },
	{ 0x1c, 0x10 },
	{ 0x1d, 0x01 },
	{ 0x30, 0x19 },
	{ 0x36, 0xff },
	{ 0x37, 0xff },
	{ 0x38, 0xff },
	{ 0x39, 0xff },
	{ 0x3a, 0x28 },
	{ 0x3b, 0x21 },
	{ 0x60, 0x02 },
	{ 0x66, 0xff },
	{ 0x67, 0xff },
	{ 0x68, 0xff },
	{ 0x69, 0xff },
	{ 0x6a, 0x08 },
	{ 0x6b, 0x09 },
	{ 0x6c, 0x0a },
	{ 0x90, 0x04 },

	// Update NVM Bank
	{ 0x0f, 0x10 },
	{ 0x00, 0x00 },
	// Proceed to Loop Lock
	{ 0x0f, 0x40 },
	{ 0x00, 0x00 },
	// INPUT_SYS : end


	// CLOCK_MON : begin
	{ 0xff, 0x06 },
	{ 0xbd, 0xc3 },
	{ 0x10, 0x10 },
	{ 0x11, 0x06 },
	{ 0x12, 0x04 },
	{ 0x13, 0x00 },
	{ 0x14, 0x64 },
	{ 0x15, 0x00 },
	{ 0x16, 0x00 },
	{ 0x17, 0x07 },
	{ 0x18, 0x00 },
	{ 0x19, 0x00 },
	{ 0x1a, 0x32 },
	{ 0x1b, 0x0b },
	{ 0x1c, 0x01 },
	{ 0x1d, 0xc6 },
	{ 0x1e, 0x01 },
	{ 0x1f, 0x6b },
	{ 0x30, 0x10 },
	{ 0x31, 0x06 },
	{ 0x32, 0x05 },
	{ 0x34, 0x64 },
	{ 0x37, 0x07 },
	{ 0x3a, 0x32 },
	{ 0x3b, 0x0b },
	{ 0x3c, 0x01 },
	{ 0x3d, 0xc6 },
	{ 0x3e, 0x01 },
	{ 0x3f, 0x6b },
	{ 0x60, 0x43 },
	{ 0x61, 0x05 },
	{ 0x62, 0x04 },
	{ 0x64, 0x64 },
	{ 0x67, 0x05 },
	{ 0x6a, 0x2e },
	{ 0x6b, 0x0b },
	{ 0x6d, 0x45 },
	{ 0x6f, 0x2e },
	{ 0x70, 0x0b },
	{ 0x71, 0xcc },
	{ 0x74, 0x55 },
	{ 0x75, 0x55 },
	{ 0x76, 0x55 },
	{ 0x77, 0x55 },
	{ 0x78, 0x55 },
	{ 0x79, 0x55 },
	{ 0x88, 0x10 },
	{ 0x8b, 0x10 },
	{ 0x8c, 0x10 },
	{ 0x8d, 0x01 },
	{ 0x8f, 0x02 },
	{ 0xa0, 0x43 },
	{ 0xa1, 0x05 },
	{ 0xa2, 0x04 },
	{ 0xa4, 0x64 },
	{ 0xa7, 0xe4 },
	{ 0xaa, 0x2c },
	{ 0xab, 0x0b },
	{ 0xad, 0x23 },
	{ 0xaf, 0x17 },


	{ 0xff, 0x07 },
	{ 0xbd, 0xc3 },
	{ 0x27, 0x33 },
	{ 0x28, 0x07 },
	{ 0x29, 0x13 },
	{ 0x2a, 0x84 },
	{ 0x2b, 0xbd },
	{ 0x2c, 0xa1 },
	{ 0x2d, 0x2f },
	{ 0x2e, 0x17 },
	{ 0x2f, 0x01 },

	// Update NVM Bank
	{ 0xff, 0x06 },
	{ 0x0f, 0x10 },
	{ 0x00, 0x00 },
	// Proceed to Loop Lock
	{ 0x0f, 0x40 },
	// CLOCK_MON : end


	// OUTSYS : begin
	{ 0xff, 0x03 },
	{ 0xbd, 0xc3 },
	{ 0x53, 0x09 },
	{ 0x54, 0x3e },
	{ 0x55, 0x40 },
	{ 0x59, 0x02 },
	{ 0x5a, 0x97 },
	{ 0x5c, 0x30 },
	{ 0x5e, 0x64 },
	{ 0x60, 0x01 },
	{ 0x61, 0x20 },
	{ 0x62, 0xd1 },
	{ 0x63, 0x80 },
	{ 0x65, 0x40 },
	{ 0x69, 0x02 },
	{ 0x6a, 0x97 },
	{ 0x6c, 0x30 },
	{ 0x6e, 0x64 },


	{ 0xff, 0x04 },
	{ 0xbd, 0xc3 },
	{ 0x14, 0x38 },
	{ 0x15, 0x40 },
	{ 0x19, 0x02 },
	{ 0x1a, 0x17 },
	{ 0x1c, 0x31 },
	{ 0x1e, 0x60 },
	{ 0x1f, 0x07 },
	{ 0x24, 0x46 },
	{ 0x25, 0x60 },
	{ 0x29, 0x02 },
	{ 0x2a, 0x17 },
	{ 0x2c, 0x30 },
	{ 0x2e, 0xa0 },
	{ 0x2f, 0x05 },
	{ 0x44, 0xa0 },
	{ 0x45, 0x40 },
	{ 0x49, 0x02 },
	{ 0x4a, 0x97 },
	{ 0x4c, 0x30 },
	{ 0x4e, 0x64 },
	{ 0x4f, 0x00 },
	{ 0x53, 0x01 },
	{ 0x54, 0xf4 },
	{ 0x55, 0x40 },
	{ 0x59, 0x02 },
	{ 0x5a, 0x97 },
	{ 0x5c, 0x30 },
	{ 0x5e, 0x64 },
	{ 0x5f, 0x00 },
	{ 0x63, 0x01 },
	{ 0x64, 0xf4 },
	{ 0x65, 0x40 },
	{ 0x69, 0x02 },
	{ 0x6a, 0x97 },
	{ 0x6c, 0x30 },
	{ 0x6e, 0x64 },
	{ 0x6f, 0x00 },

	// Update NVM Bank
	{ 0xff, 0x03 },
	{ 0x0f, 0x10 },
	{ 0x00, 0x00 },
	// Proceed to Loop Lock
	{ 0x0f, 0x40 },
	// OUTSYS : end


	// PLLE : begin
	{ 0xff, 0x0e },
	{ 0xbd, 0xc3 },
	{ 0x09, 0xc0 },
	{ 0x10, 0x90 },
	{ 0x11, 0x7d },
	{ 0x12, 0xd0 },
	{ 0x13, 0xab },
	{ 0x14, 0x56 },
	{ 0x15, 0x87 },
	{ 0x16, 0x01 },
	{ 0x18, 0x07 },
	{ 0x19, 0x62 },
	{ 0x1f, 0xb2 },
	{ 0x22, 0x32 },
	{ 0x24, 0x87 },
	{ 0x25, 0x87 },
	{ 0x26, 0x42 },
	{ 0x29, 0x1d },
	{ 0x2a, 0x32 },
	{ 0x2b, 0x66 },
	{ 0x2c, 0x10 },
	{ 0x2d, 0x18 },
	{ 0x2e, 0x44 },
	{ 0x2f, 0x07 },
	{ 0x30, 0x52 },
	{ 0x31, 0x40 },
	{ 0x32, 0x7d },
	{ 0x33, 0xf6 },
	{ 0x34, 0x12 },
	{ 0x35, 0x1a },
	{ 0x38, 0xb3 },
	{ 0x39, 0xff },
	{ 0x3a, 0xff },
	{ 0x3b, 0xff },
	{ 0x3c, 0xf8 },
	{ 0x3d, 0x14 },
	{ 0x3e, 0x87 },
	{ 0x3f, 0x01 },
	{ 0x42, 0x48 },
	{ 0x48, 0x01 },
	{ 0x49, 0xff },
	{ 0x4a, 0xff },
	{ 0x4b, 0xff },
	{ 0x4c, 0xff },
	{ 0x4d, 0x80 },
	{ 0x4e, 0x0f },
	{ 0x4f, 0xdf },
	{ 0x57, 0x40 },
	{ 0x7f, 0x40 },

	// Update NVM Bank
	{ 0x0f, 0x10 },
	{ 0x00, 0x00 },
	// Proceed to Loop Lock
	{ 0x0f, 0x40 },
	// PLLE : end
	{ 0x00, 0x00 },


	// PLLA : begin
	{ 0xff, 0x0a },
	{ 0xbd, 0xc3 },
	{ 0x09, 0xc0 },
	{ 0x10, 0xf4 },
	{ 0x11, 0x76 },
	{ 0x12, 0xf3 },
	{ 0x13, 0xf2 },
	{ 0x14, 0x67 },
	{ 0x15, 0x8d },
	{ 0x16, 0xff },
	{ 0x17, 0x02 },
	{ 0x18, 0x2f },
	{ 0x19, 0x54 },
	{ 0x1f, 0xe8 },
	{ 0x22, 0x32 },
	{ 0x24, 0x23 },
	{ 0x25, 0x84 },
	{ 0x26, 0xc2 },
	{ 0x28, 0x61 },
	{ 0x29, 0x1d },
	{ 0x2a, 0x32 },
	{ 0x2b, 0x66 },
	{ 0x2c, 0x12 },
	{ 0x2d, 0x18 },
	{ 0x2e, 0x74 },
	{ 0x2f, 0x07 },
	{ 0x30, 0x2e },
	{ 0x31, 0x40 },
	{ 0x32, 0xf0 },
	{ 0x33, 0x12 },
	{ 0x34, 0xda },
	{ 0x35, 0x4b },
	{ 0x38, 0xe9 },
	{ 0x39, 0xff },
	{ 0x3a, 0xff },
	{ 0x3b, 0xff },
	{ 0x3c, 0xf8 },
	{ 0x3d, 0x15 },
	{ 0x3e, 0xa0 },
	{ 0x3f, 0x0f },
	{ 0x42, 0x08 },
	{ 0x49, 0xff },
	{ 0x4a, 0xff },
	{ 0x4b, 0xff },
	{ 0x4c, 0xff },
	{ 0x4d, 0xc0 },
	{ 0x4e, 0x20 },
	{ 0x4f, 0xc7 },
	{ 0x57, 0x40 },
	{ 0x7f, 0x40 },
	{ 0x90, 0x05 },

	// Update NVM Bank
	{ 0x0f, 0x10 },
	{ 0x00, 0x00 },
	// Proceed to Loop Lock
	{ 0x0f, 0x40 },
	// PLLA : end


	// PLLB : begin
	{ 0xff, 0x0b },
	{ 0xbd, 0xc3 },
	{ 0x09, 0xc0 },
	{ 0x10, 0xf4 },
	{ 0x11, 0x76 },
	{ 0x12, 0xf3 },
	{ 0x13, 0x30 },
	{ 0x14, 0x67 },
	{ 0x15, 0x8d },
	{ 0x16, 0xff },
	{ 0x17, 0x02 },
	{ 0x18, 0x2f },
	{ 0x19, 0x54 },
	{ 0x1f, 0xe0 },
	{ 0x22, 0x32 },
	{ 0x24, 0x23 },
	{ 0x25, 0x84 },
	{ 0x26, 0xc2 },
	{ 0x28, 0x06 },
	{ 0x29, 0x1d },
	{ 0x2a, 0x32 },
	{ 0x2b, 0x66 },
	{ 0x2c, 0x12 },
	{ 0x2d, 0x18 },
	{ 0x2e, 0x76 },
	{ 0x2f, 0x07 },
	{ 0x30, 0x41 },
	{ 0x31, 0x40 },
	{ 0x32, 0x2a },
	{ 0x33, 0xb4 },
	{ 0x34, 0x97 },
	{ 0x35, 0xd0 },
	{ 0x38, 0xe9 },
	{ 0x39, 0xff },
	{ 0x3a, 0xff },
	{ 0x3b, 0xff },
	{ 0x3c, 0xf8 },
	{ 0x3d, 0x15 },
	{ 0x3e, 0xe0 },
	{ 0x3f, 0x15 },
	{ 0x42, 0x08 },
	{ 0x49, 0xff },
	{ 0x4a, 0xff },
	{ 0x4b, 0xff },
	{ 0x4c, 0xff },
	{ 0x4d, 0xc0 },
	{ 0x4e, 0x20 },
	{ 0x4f, 0xc7 },
	{ 0x57, 0x40 },
	{ 0x7f, 0x40 },
	{ 0x90, 0x05 },

	// Update NVM Bank
	{ 0x0f, 0x10 },
	{ 0x00, 0x00 },
	// Proceed to Loop Lock
	{ 0x0f, 0x40 },
	// PLLB : end


	// PLLC : begin
	{ 0xff, 0x0c },
	{ 0xbd, 0xc3 },
	{ 0x09, 0xc0 },
	{ 0x10, 0xb4 },
	{ 0x11, 0x76 },
	{ 0x12, 0xf3 },
	{ 0x13, 0x51 },
	{ 0x14, 0x67 },
	{ 0x15, 0x8d },
	{ 0x16, 0xff },
	{ 0x17, 0x02 },
	{ 0x18, 0x2f },
	{ 0x19, 0x56 },
	{ 0x1f, 0xe8 },
	{ 0x22, 0x32 },
	{ 0x24, 0x23 },
	{ 0x25, 0x84 },
	{ 0x26, 0xc2 },
	{ 0x27, 0x01 },
	{ 0x28, 0x80 },
	{ 0x29, 0x0d },
	{ 0x2a, 0x32 },
	{ 0x2b, 0x66 },
	{ 0x2c, 0x52 },
	{ 0x2d, 0x1c },
	{ 0x2e, 0x75 },
	{ 0x2f, 0x07 },
	{ 0x30, 0x2d },
	{ 0x31, 0x40 },
	{ 0x32, 0x6e },
	{ 0x33, 0x74 },
	{ 0x34, 0xca },
	{ 0x35, 0xdd },
	{ 0x38, 0x19 },
	{ 0x39, 0xf4 },
	{ 0x3a, 0xff },
	{ 0x3b, 0xff },
	{ 0x3c, 0xf8 },
	{ 0x3d, 0x15 },
	{ 0x3e, 0x24 },
	{ 0x3f, 0x0f },
	{ 0x43, 0x34 },
	{ 0x44, 0x8e },
	{ 0x45, 0x53 },
	{ 0x46, 0x74 },
	{ 0x49, 0x5b },
	{ 0x4a, 0xfe },
	{ 0x4b, 0xff },
	{ 0x4c, 0xff },
	{ 0x4d, 0xc0 },
	{ 0x4e, 0x20 },
	{ 0x4f, 0xc7 },
	{ 0x57, 0x40 },
	{ 0x7f, 0x40 },
	{ 0x90, 0x05 },

	// Update NVM Bank
	{ 0x0f, 0x10 },
	{ 0x00, 0x00 },
	// Proceed to Loop Lock
	{ 0x0f, 0x40 },
	// PLLC : end
	{ 0x00, 0x00 },

	// NVM END HERE
};


struct au5508_device {
	/* device handling related values */
	dev_t			devt;
	int			minor;
	struct device		*dev;
	struct cdev		*cdev;
	struct spi_device	*spi;
	struct regmap *regmap;
	struct gpio_desc *reset_gpio;
	struct gpio_desc *reset_switch_gpio;
	
};

struct au5508_instance {
	struct au5508_device	*device;
	int reserved;
};

static const struct regmap_config regmap_config = {
	.name = "au5508",
	.reg_bits = 16,
	.val_bits = 8,
	.use_single_read = 1,
	.use_single_write = 1,
	.read_flag_mask = 0x00,
	.write_flag_mask = 0x80,
	.cache_type = REGCACHE_NONE,
	.max_register = 0x100,
	.can_multi_write = false,

};

static int au5508_reg_init(struct au5508_device	*device)
{
	int i = 0; 
	int ret=0;
    for (i = 0; i < sizeof(au5508_register_cfg) / sizeof(au5508_reg); i++){
        unsigned int rval = 0;
        if(0==au5508_register_cfg[i].offset) {
            mdelay(100);
            continue;
        }

        ret = regmap_write(device->regmap,au5508_register_cfg[i].offset, (au5508_register_cfg[i].val));
        if (ret != 0) return -EINVAL;
        ret = regmap_read(device->regmap,au5508_register_cfg[i].offset, &rval);
        if (ret != 0) return ret;
        if (rval != au5508_register_cfg[i].val) {
            printk("reg=0x%x,write_val=0x%x, read_val=0x%x \n",au5508_register_cfg[i].offset,au5508_register_cfg[i].val, rval);
        }
    }
	return ret;
}


static int au5508_write_reg(struct au5508_device *dev, unsigned char address,
			     unsigned char data)
{
    struct spi_device *spi = (struct spi_device *)dev->spi;

	unsigned char buf[3];
	buf[0] = 0x80;
	buf[1] = address;
	buf[2] = data;

	return spi_write_then_read(spi, buf, 3, NULL, 0);
}

static int au5508_read_reg(struct au5508_device *dev, unsigned char address,
			    unsigned char *data)
{
	//struct spi_device *spi = to_spi_device(dev);
    struct spi_device *spi = (struct spi_device *)dev->spi;
	unsigned char buf[2];
	buf[0] = 0x00;
	buf[1] = address;
	return spi_write_then_read(spi, buf, 2, data, 1);
}

long au5508_get_message(struct au5508_device *dev,unsigned long arg)
{
	 struct spi_ioc_transfer tr;
	 void __user *argp = (void __user *)arg;
	 struct spi_ioc_transfer *u_tmp;


	if (copy_from_user(&tr, argp, sizeof(struct spi_ioc_transfer)))
		return -EFAULT;
	u8 data=0xff;
	unsigned char addr;
	unsigned char temp[3];
	memcpy(temp,(unsigned char *)tr.tx_buf,tr.len);

	addr=temp[1];
	au5508_read_reg(dev,addr,&data);

	if (copy_to_user((void __user *)arg, &data, sizeof(unsigned char)))
		return -EFAULT;
	return 0;
}

long au5508_set_message(struct au5508_device *dev,unsigned long arg)
{
	struct spi_ioc_transfer tr;
	u8			*tx_buf;
	struct spi_ioc_transfer *u_tmp;


	void __user *argp = (void __user *)arg;
#if 0
	if (copy_from_user(&tr, argp, sizeof(struct spi_ioc_transfer)))
		return -EFAULT;
#endif
	if(copy_from_user(tx_buf, (const u8 __user *)(uintptr_t) u_tmp->tx_buf,u_tmp->len))
		return -EFAULT;
	unsigned char data;
	unsigned char addr;
	unsigned char temp[3];
	memcpy(temp,(unsigned char *)tr.tx_buf,tr.len);
	addr=temp[1];
	data=temp[2];

	au5508_write_reg(dev,addr,data);
	return 0;
}

static long au5508_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	struct au5508_instance	*instance;
	struct au5508_device	*device;
	int ret=0;


	instance = filp->private_data;
	device = instance->device;

	switch (cmd) {
	case AU5508_SET_CONTEXT:
		ret = au5508_set_message(device,arg);
		break;
	case AU5508_GET_CONTEXT:
		ret = au5508_get_message(device,arg);
		break;
	default:
		break;
	}
	return ret;
}

/*-------------------------------------------------------------------------*/

static int au5508_open(struct inode *inode, struct file *filp)
	{
		struct au5508_device *device;
		struct au5508_instance	*instance;
	
		mutex_lock(&minor_lock);
		device = idr_find(&au5508_idr, iminor(inode));
		mutex_unlock(&minor_lock);
		if (!device) {
			pr_debug("device: minor %d unknown.\n", iminor(inode));
			return -ENODEV;
		}
	
		instance = kzalloc(sizeof(*instance), GFP_KERNEL);
		if (!instance)
			return -ENOMEM;
	
		/* setup instance data*/
		instance->device = device;
	
		/* instance data as context */
		filp->private_data = instance;
		stream_open(inode, filp);
	
		return 0;
	}



static int au5508_release(struct inode *inode, struct file *filp)
{
	struct au5508_instance	*instance;
	instance = filp->private_data;
	kfree(instance);
	filp->private_data = NULL;
	return 0;
}

static int au5508_get_minor(struct au5508_device *device)
{
	int retval = -ENOMEM;

	mutex_lock(&minor_lock);
	retval = idr_alloc(&au5508_idr, device, 0, N_AU5508_MINORS, GFP_KERNEL);
	if (retval >= 0) {
		device->minor = retval;
		retval = 0;
	} else if (retval == -ENOSPC) {
		dev_err(&device->spi->dev, "too many au5508 devices\n");
		retval = -EINVAL;
	}
	mutex_unlock(&minor_lock);
	return retval;
}

static void au5508_free_minor(struct au5508_device *dev)
{
	mutex_lock(&minor_lock);
	idr_remove(&au5508_idr, dev->minor);
	mutex_unlock(&minor_lock);
}

/*-------------------------------------------------------------------------*/

static const struct file_operations au5508_fops = {
	.owner =	THIS_MODULE,
	.unlocked_ioctl = au5508_ioctl,
	.open =		au5508_open,
	.release =	au5508_release,
	.llseek =	no_llseek,
};


/*-------------------------------------------------------------------------*/


static int au5508_probe(struct spi_device *spi)
{
	struct au5508_device	*device;
	int			retval;
	int ret;
	

	spi->mode = SPI_MODE_0;
	spi->bits_per_word = 8;
	spi->max_speed_hz= 1000000;
	spi->word_delay.value= 10;
	spi->word_delay.unit=SPI_DELAY_UNIT_USECS;
	ret = spi_setup(spi);
	if (ret < 0) {
		dev_err(device->dev, "spi setup failed.\n");
		return ret;
	}	
	
	/* Allocate driver data */
	device = kzalloc(sizeof(*device), GFP_KERNEL);
	if (!device)
		return -ENOMEM;
	device->reset_gpio = devm_gpiod_get_optional(&spi->dev, "reset",
						  GPIOD_OUT_LOW);
	if (device->reset_gpio) {
		/* Reset au5508 */
		gpiod_set_value_cansleep(device->reset_gpio, 1);
		mdelay(2);
		gpiod_set_value_cansleep(device->reset_gpio, 0);
		mdelay(100);
	}

	device->regmap = devm_regmap_init_spi(spi, &regmap_config);
	if (IS_ERR(device->regmap)) {
		dev_err(device->dev, "%s: regmap allocation failed: %ld\n",

			__func__, PTR_ERR(device->regmap));
		ret = PTR_ERR(device->regmap);
		return -1;
	}
	ret=au5508_reg_init(device);
	if (ret < 0) {
		dev_err(device->dev, "clk au5508 init failed.\n");
		return ret;
	}
	device->reset_switch_gpio= devm_gpiod_get_optional(&spi->dev, "reset-switch",
						  GPIOD_OUT_LOW);
	if (device->reset_switch_gpio) {
		/* Reset switch */
		gpiod_set_value_cansleep(device->reset_switch_gpio, 1);
		mdelay(4);
		gpiod_set_value_cansleep(device->reset_switch_gpio, 0);
		mdelay(200);
	}

	/* Initialize the driver data */
	device->spi = spi;

	/* determ minor number */
	retval = au5508_get_minor(device);
	if (retval) {
		dev_dbg(&spi->dev, "get of minor number failed\n");
		kfree(device);
		return -ENOMEM;
	}

	/* create device */
	device->devt = MKDEV(MAJOR(au5508_dev), device->minor);
	device->dev = device_create(au5508_class,
				    &spi->dev,
				    device->devt,
				    device,
				    "au5508.%d",
				    device->minor);
	if (IS_ERR(device->dev)) {
		pr_err("clk au5508: device register failed\n");
		retval = PTR_ERR(device->dev);
		kfree(device);
		goto device_create_failed;
	} else {
		dev_dbg(device->dev,
			"created device for major %d, minor %d\n",
			MAJOR(au5508_dev),
			device->minor);
	}

	/* create cdev */
	device->cdev = cdev_alloc();
	if (!device->cdev) {
		dev_dbg(device->dev, "allocation of cdev failed\n");
		kfree(device);
		return -ENOMEM;

	}
	device->cdev->owner = THIS_MODULE;
	cdev_init(device->cdev, &au5508_fops);
	retval = cdev_add(device->cdev, device->devt, 1);
	if (retval) {
		dev_dbg(device->dev, "register of cdev failed\n");
		kfree(device);

		goto del_cdev;
	}
	/* spi setup */
	spi_set_drvdata(spi, device);

	return 0;

del_cdev:
	cdev_del(device->cdev);

device_create_failed:
	au5508_free_minor(device);

	return retval;
}

static void au5508_remove(struct spi_device *spi)
{
	struct au5508_device	*device = spi_get_drvdata(spi);


	/* make sure ops on existing fds can abort cleanly */
	device->spi = NULL;

	device_destroy(au5508_class, device->devt);

	cdev_del(device->cdev);

	au5508_free_minor(device);

	kfree(device);
}

static const struct of_device_id au5508_dt_ids[] = {
	{ .compatible = "aurasemi,au55xx" },

	{},
};

MODULE_DEVICE_TABLE(of, au5508_dt_ids);

static struct spi_driver au5508_spi_driver = {
	.driver = {
		.name =		"au5508",
		.owner =	THIS_MODULE,
		.of_match_table = of_match_ptr(au5508_dt_ids),
	},
	.probe =	au5508_probe,
	.remove =	au5508_remove,

	/*
	 * NOTE:  suspend/resume methods are not necessary here.
	 * We don't do anything except pass the requests to/from
	 * the underlying controller.  The refrigerator handles
	 * most issues; the controller driver handles the rest.
	 */
};

/*-------------------------------------------------------------------------*/

static int __init au5508_init(void)
{
	int status;

	/*
	 * Claim device numbers.  Then register a class
	 * that will key udev/mdev to add/remove /dev nodes.
	 * Last, register the driver which manages those device numbers.
	 */
	status = alloc_chrdev_region(&au5508_dev, 0, N_AU5508_MINORS, "au5508");
	if (status < 0)
		return status;

	au5508_class = class_create("au5508");
	if (IS_ERR(au5508_class)) {
		unregister_chrdev(MAJOR(au5508_dev),
				  au5508_spi_driver.driver.name);
		return PTR_ERR(au5508_class);
	}

	status = spi_register_driver(&au5508_spi_driver);
	if (status < 0) {
		class_destroy(au5508_class);
		unregister_chrdev(MAJOR(au5508_dev),
				  au5508_spi_driver.driver.name);
	}

	return status;
}

module_init(au5508_init);

static void __exit au5508_exit(void)
{
	spi_unregister_driver(&au5508_spi_driver);
	class_destroy(au5508_class);
	unregister_chrdev(MAJOR(au5508_dev), au5508_spi_driver.driver.name);
}
module_exit(au5508_exit);

MODULE_AUTHOR("Marcus Wolf, <linux@wolf-entwicklungen.de>");
MODULE_DESCRIPTION("Driver for Au5508");
MODULE_LICENSE("GPL");
MODULE_ALIAS("spi:au5508");
